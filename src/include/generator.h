//REV: 4 Apr 2016
//generator.h
//generator class for user to make generators to generate actual models (implemented symmodels)



//TODO:
//I need to generate the size.
//Generators can be:
//  GLOBAL (i.e. this will generate "the whole thing" themselves)
//  LOCAL (they MAY generate some part locally ). What determines number of local to call? Num of pre-post pairs, etc.? I.e. a GLOBAL-inside-LOCAL

//  In local case, it simply re-combines all LOCAL guys together at the end.
//  Can we nest, local in local?
//  Basically, GLOBAL is a local with size=1.

//REV: how can I reference a "constant" variable? I can do it, but it requires it to know it is a global variable haha.
//Just mark varible "isglobal" or some shit? Or have a subset that are certain values? In that way, make corresp...do it later.
//Just generate single variable, it's "constant", and I mark that it is the case.
//Also mark "param" (i.e. can't be modified by update function), etc.? Problem is e.g. some previous params like weight might be turned into vars by
//additional models?

//OK so for generating synapses
//I first compute "distances" matrix, which is npre*npost. Then, I can use that for computation...too complex. I can optimize it...but yea.
//Anyway, it's a variable...
//Do generators have variables too? Yea, and some may be local???
//I compute dists to all. Fine. And they have corresp ok

//OK, so at very beginning, how do I specify the number of guys and what they operate on?
//I am (co-) generating "pre->post". I.e. generating synapse location.
//Generators must operate on some other thing. E.g. in this case um, it does a "FOR" all presyn neurons or something.
//And, for each presyn neuron, it executes a generator, which does a "FOR" through all postsyn neurons. OK, so just like a "DO_FOR_ALL".
//They're holes? Fuck. I need to "execute-for-each" type thing. Or like "push-back", like it builds a vector. Gotcha.
//And the global generator, it builds something.

//So, equivalent to other guy, but instead of returning real_t, it returns vector<real_t>.
//And I (always) combine them into a single one later? Fine, that means I need to re-code all that shit...
//So, I just call a thing that does like


//HOW TO SPECIFY pre/post model of correspondence? Corresp always go through a hole I guess? If I use 3 arrows, then how do I reference pre/post?
//It just references (literally) a model. I just specify the variable... But I want a way to refer to postsyn x/y/z of it.


//REV: add/make temp variable in generator.
//Specifically pre-post will generate correspondence and etc. by generating dist()
//So, I make a generator, and for generators I can add variables haha..
//The variables are then generated by other generators. Holy shit.
//These variables are always accessible at base level? I.e. not resolved in symmodel, but in generator-model or some shit?
//Or are they stored temporarily in symmodel? Fuck...
//I need a way of generating real temporary variables.
//This is getting complex. I need a way of knowing which must be read/generated first. That is why I can't just write direct function.
//It might be some complex function of things. Um, anyway, for each it generates it then generates some number from a set distribution?
//Like from a multinomial? Nah, just independently do it for now (much easier?)...but it requires knowing the full thing?
//For example if I am drawing N from it, meh, fine. Figure it out later. Just generate a normalized thing from it, based on post size
//Which has a target for "how many" I will generate? In other words, generate integral basically haha...
//This will be based on a density, which will change based on width of distribution, i.e. modulating C etc. So, we need to normalize it by the
//area? Or something? Total number of synapses will change significantly between guys... is that OK? Allow multiple synapses per N->N pair.
//So, I get rough number I want, then just do draws normalized by that number. That is fine, I need to compute prob integral first?
//I can't easily analytically compute integral without knowing the number. E.g. I compute the integral, compute how many I want? What if I'm on the
//side? Then obviously I should reduce it by the amount I am off the side... Pain in the ass. Just draw it straight/literally? But then number might
//significantly change... and weights can't be directly compared I guess? Better to know "ideal" amount of one at center, and use that?
//And I use my proportion of that. Integral of part of 2d gaussian,....fuck.
//No, distribute synapses totally independently of source-target. Pre is selected at uniform, and then post is selected using multinomial.
//No, that won't solve the issue, it will still draw, but just less likely...

//Well...well fuck. I can implement any of these with generator of course. But, what should I do ?
//Specify a density, fine. That is a given number of synapses for any.
//Going post-pre is safer, because that way there may be some inside, which come from outside. However, a problem is that overally, those on the edge
//should be receiving fewer POSTSYN from within the circuit too, due to the fact that since we are a slice, some of my presyns would have been "outside"
//the circuit.

//Unless I do some correction, either edges will have too many presyns or too many postsyns, compared to the actual circuit.
//Estimating how many fewer, will be dependent on the specific width parameters...no actually not. Not if neurons are close.
//But how far away from the edge they're affected, that is done. I can integrate my "actual" integral, and compare it to a "maximal" guy
//located at the center of the circuit. My overall density is my comparison comopared to that, that determines my relative probability of
//being selected. OK.

//Compute my distance matrix.
//Compute probability for each guy.
//Compute integral of mine based on sum probability.
//Compute fake integral of guy placed at center of circuit (how can I do this?).
//Sum of all integrals is estimated actual number. Edges will remove unnecessary guys. So, those guys literally just have normalization by normal amount,
//i.e. overall will generate fewer guys, due to lower probability.
//Fine.
//I can run a "test" example, which will tell which ones are read/written in there... that is enough.
//yea, just generate it straight, don't write as a generator.
//I can run a "check" for each to make sure.


//Yea, make local variables after all...which need to have corresp? I.e. start/end fuck.
//Eventually I need to "bubble back" to compute total integral estimated. Fuck.
//So, yea, making temporary variables is a big thing.
//Will it generate a new symvar?
//Will it generate a corresp?

//REV: I can simplify things I guess...I can specify generating new variable in real time.

//For example, this makes 2d array I guess...
//probarrays = DOFORALL( neurons, DOFORALL( neurons, EXP( dist(pre, post) * a ) ) )

//this makes a 1d array
//This is how many I will "actually make"
//integrals = DOFORALL( neurons, SUM( probarrays ) ) //this is actual number expected to create for each I guess?

//idealx = (maxx-minx)/2 + minx;
//idealy = (maxy-miny)/2 + miny;
//idealz = (maxz-minz)/2 + minz;

//idealinteg = SUMFORALL( postneurons, DIST( x, y, z, postneurons/x, postneurons/y, postneurons/z ) )
//sumidealinteg = SUMFORALL( neurons, 1) * idealinteg

//this makes 1 value
//sumint = SUM( integrals )

//REV: No, estimate how much I "would" make by doing middle neuron * nneurons.
//This way, I get an estimate for real density. This way, e.g. I "overestimate" the number I am creating. So I will reduce the actual number?

//correctionratio = (targdensity*volume) / sumidealinteg    //E.g. if target is 1000, and I'm making 2000, I need to multiply everything by 1/2

//integrals = DOFORALL( neurons, integrals * correctionratio ) //Now, each one knows how many it "should" create (in reality)

//Now, actually generate for each one using oroginal probarrays, which will do prob normalization.

//For the last one, I only generate one by normalizing to the remaining value, i.e. if it is 1.5 neurons, I normalize to 0.5, uniform to see if it is generated, then only
//generate if it is. OK.

//resulting_synapses = DOFORALL( neurons, MULTINOM( probarrays, integrals ) ) //integrals is how many I draw for each.
//Based on this, I need to add (preidx, postidx) of the guy. Preidx is neurons[idx]. Postidx is the selected probarrays[idx]. In other words, I co-generate that ;)

//BAM, DONE! :)

//Now, main issue is to figure out how to create temporary variables, and keep track of indices and correspondences. "easiest" is to force user to specify all variables
//and generate with generators beforehand.
//But that is not realistic. We want to have arbitray mechanism for generating. If I have user specify "list", it will execute each with desired number of threads.
//If I set a variable in a DOFORALL, it will create a new vector with those results.
//Problem is, it will "push" vector<vector> etc.?
//Easiest is everything returns a vector of SOMETHING.
//To reference variables by string name inside, it's a problem. It needs to be added as a "string".
//I treat them as temporary members? Or as a new (sub)model?
//A local model of what size?

//For example, if I make vector of vectors, I'm just making vector, with correspondence of one-to-many. Which it returns as a temporary variable in a temporary model. OK.
//Which has a size.
//I have functions to "addmodel" (or variable...?) to models there ;)
//Basic variables are stored at base level, and are of size one I guess...
//Every variable has its own model? Nah...

//Make it easy to generate base corresopndence, which is direct

//Basically, I need to add functions to add new models/variables, and to set their size (i.e. push_to_var).

//First, I generate a model which is probs for each presyn to each postsyn. This is "easy", in that I iter for every
// presyn, ADDTOVAR type thing. In other words, my size is just nneurons?
// Or, I generate a varaible one at a time, I generate nneurons probability or something.
// Then, I generate a new guy, which is, for each of those, I am generating new, and it combines them all at end.
// Every time it does it, when it combines it, it knows to generate the new guy?
//Best idea, only allow it to generate one new model/var guy each time. That is fine.
//By doing "add" it automatically knows to also add the correspondences. At "coalescence" time, it does the large-to-small correspondence building?
//by keeping track/building the PRE idx of what is generating this array part (i.e. I make an n-long array of twos, for generating the n-long array of values
//for idx 2)


//REV: fine, so do it.

//Syntax is basically same.

//Problem is, I literally have poitner to symbmodel to access individual guys. Problem is that relationship of "me" to original guys in symmodel is not obvious.
//For neurons, it is one-to-one (that's good to know?)

//So, make a deep copy of it, and literally add the variables in?
//This is the last issue...relationship of all that...

//Yea, it's a deep copy of the symmodel, fuck.
//Oh, as long as it does not modify any local variables, it doesn't hurt anything.
//So, just add it directly in to that. I.e. adding new top-level models where it is OK, or adding variables where it is convenient.
//I like that...

//Note, if this is done on GPU, we may need to do it in different kernels, to ensure we are appropriately summing all values? That's fine though.
//Every "line" is a different kernel I guess...? Different kernels need to handle the thing made by each one, ugh. Zero-thread will need to do the coalescing.
//Which is only possible at end of kernel since we are using more than one block.



//genmodel

//genmodel.addmodel(blah).


//THINGTODO = vector<real_t> myprobs = 
//generate_corresp( "syn2-1/postsyn", "DOFORALL( syn2-1/postsyn, DOFORALL( syn2-1/presyn, THINGTODO) ) )"


//OK, so only difficult thing is to generate "each".

//THINGTODO = ADDIF( syn2-1/postsyn )
//generate_corresp( "syn2-1/postsyn", "DOFORALL( syn2-1/postsyn, DOFORALL( syn2-1/presyn, THINGTODO ) )" )

//(co-) generator for syn2-1/syn2-1->adex2
//OK. Specific generation is:
//It's like a hole basically. We get pre/post of syn2-1
//DOFORALL( sc/syn2-1->sc/adex2 )



//REV: TODO: I can "fill" all correspondences by doing "other side". I just check that target model is smaller, and then do the thing.


#pragma once

#include <symmodel.h>



struct genfunct_t
{
  vector<string> lines;
  //gencmdstore cmds;
  cmdstore cmds; //Problem is that these all return real_t. This is uh, fine, however we want to be able to CREATE/ADD guys. And do the same thing for SIZE_T
  //lol convert real_t to size_t? Will that ever fuck up? Literally copy everything for size_t as well?
  std::shared_ptr<generator> gen;


  void execute( const size_t& myidx )
  {
    for(size_t l=0; l<lines.size(); ++l)
      {
	vector<elemptr> trace;
	elemptr tmp( gen->model, myidx );
	trace.push_back(tmp);
	DOCMD( lines[l], trace, cmds );
      }
  }

  void add( const string& s )
  {
    lines.push_back( s );
  }

genfunct_t() // const std::shared_ptr<generator>& g )
//: gen(g )
  {
  }
}; //end struct genfunct_t


//So, I have functions implemented which:
//Take model as argument. They include commands. For example, add().
//Note, each one, may e.g. generate its own element. Which it will finally return (INSIDE THE FUNCTION). In fact, it may have created many of them.
//The problem is, each one is returning not a real_t, but something else. E.g. a vector<real_t>.
//This is the source of the problem.

//Note, I need to be able to refer to var/idx to indicate I mean the idx in the var.

//So, simple example.

//I want to 1) compute for each presyn neuron, compute its "prob" for each postsyn neuron.
//This means I will create a new variable/model. The model will be created by:
//createvar( integ, foreach( presyn, foreach( postsyn, DOBLAH ) ) );
//So, this will in innermost, it will do e.g. for presyn[0], it will iter through postsyn, and do something. Finally, it will return some vector. Those each were compressed
//in variable. Problem is, that was passed as arg, so it needs to return VECTOR<real_t> not real_t. Fuck...
//Note, "foreach" it adds to a vector. That is the problem they might be done in parallel (?). That's fine, this is not parallelized. So, at each one, it pushes back to the
//FINAL vector, my guy. With correspondence presyn[0], postsyn[x]. Literally, everything is being compressed. In other words, even though it is a submodel eventually...
//Hm, that's problem though...when I go through. It is way more optimal to just assume a vector<real_t> is returned. This is only really important if I will be
//doing something like implementing a PUSH_BACK.
//Innermost will be DOBLAH, it will be specifically, in this case, measure distance, and add that.

//REV: How do I handle variables passed in from e.g. varlist? They are constants I guess? Are they stored in model at top level? They should not stay around over gens.

//Oh, but  user may have hand-specified them from file or something? Like user literally passes in his own array (variables) that we will use.
//Thus, we must be able to access those. Assume they are always placed under a specific special model that user has chosen the name of?
//How does he pass other variables into there otherwise? Like, size=3, or density=0.005. Where do things like "density" come from.
//Or size. Or if he just literally manually specifies VM for each model that is great. FOr "loading" purposes.
//Force user to have set them at beginning of GEN (passed as literal symvars, which are set up as individual symmodels I guess?).
//They then have no correspondence, fuck. Or, all models have all-to-one correspondence to them. Like, when I try to access the index of it, it will fuck up...
//Manually set corresp to all relevant guys to be all-to-one?

//What about in case where it is of a set size. And I want to literally use that, like forall( in that), equls that. Or simple thing, like mult that times something for that.
//Great. So, in case user specifies large variable or set of variables (in models), which, by the way, must be always referenced from the root level???? In other words,
//fuck. I need to name a model like, genmodel. It doesn't need to be in here? or does it? If it is in here, yay. If not, we will still not be able to find it naturally, fuck.
//always artificially add it to the start of the trace? Richard, you're overthinking things here...
//But, rewriting everything for generators is nasty...esp for GPU.
//literally add a "global model" store to all calls? A list of variables that are also searched for desired one? That's fine...
//Or, newly generated ones I guess? Like "temp model store". That is fine. And they may or may not have correspondences to me. They will
//OK, I'm liking this idea...?
//During normal exec, those don't do anything.

//OK, so to all functions, I add an additional (?) argument to trace, which is the "globalstore". And so, nested, whenever I try to "read" or "write" variable, I first
//search for it. If I do not find it in normal place, BEFORE I FAIL, if I am writing, I will add/try to write to global store.
//If I am reading, I will try to read from global store.
//If global store clash with local variables, we are in trouble.
//I...I think I can do this.

//The difficulty will come when I try to construct correspondences between global store and the normal symmodel.
//Will there be a problem? As I build the model itself, I build the correspondences.
//And they have correspondences between those models.
//As I push back a member to the global model, I push back a correspondence to all guys I need to push it back to.

//So, let's imagine a crazy case, where we have um, circuit min/max etc.

//EXAMPLE: generate neur positions:
//GLOBAL STORE:
//minx, maxx, density, etc. These are size 1. They have no inter-correspondences.
//neurx, neury, neurz, etc.. These *do* have length. They are size 100. Fine.
//OK, so now, I literally will iter through them (problem?)
//Because I'm calling DOCMD( arg, trace, cmds, globalstore )
//It will search in globalstore first I guess.
//Generating NEURONPOS: variable pos3d/x pos3d/y pos3d/z
//The problem is if I generate only one at a time, the first one sets the size, the rest can no longer push back (to the model). Oh wait, they can I guess...
//Will it check size? How will I access the variable if it is a single value? It will try to read "CORRESP"?
//I.e. adding single variable is fine... i.e. I'm adding a "gen" model, named something. Fine... gen/neurx or some shit.
//Single variables are "global". Otherwise I need a correspondence. Fine.
//FORALL( neurx, ADDTO( pos3d/x, neurx*density ) )
//FORALL( neury, ADDTO( pos3d/y, neury*density ) )

//It will have neurx == 0, 1, 2, 3, etc.
//Then, it will find neurx[0], [1], etc. and add those values to pos3d/x. That is also fine.
//However, when it wants to find "Density" with an index, it will find only single value. We only support 1-1 (identity) or all-1 (const parameter) correspondences at gen time.
//It checks in it, and it finds the appropriate. At gen time, if we are reading from correspondence. The only thing that matters is um, if we are reading from global store
//we only check if it is a PARAM or not. If param, return PARAM corresp, else return IDENTITY corresp. If sizes are not the same, error out (note it never checks in identity
//since it does not actually hold post/pre).

//OK, global store is 1) vect of symmodels 2) vect of vars 3) symmodel containing symmodels.
//If (3), it is (relatively?) easy, but problem is I will pass an empty trace...which causes problems?
//Whenver I try to "get" (?) I don't just try to get or add from model in main, but I look in globalstore first.
//globalstore is named e.g. "globalstore/model or whatever"
//How do I know when to add a new var?
//Just add vars! Much easier. Vars and correspondences. Array of. Fine. But, might want to have "size" too?
//Note, "temp" vars I'm creating are created in global store. Problem is if I don't find it there, I will try to create elsewhere, (can't find in main model? exit?)

//It only cares about presyn SIZE (modelsize!)
//Note in second FOREACH, it is a problem because it will look for "postsyn" in presyn (e.g. adex2). Furthermore, there is no correspondence between them.
//That's fine, FOREACH( passes index directly). It's not a hole. It's a nested loop...
//exists in global scope parameter A
//MAKETMPVECT( neurprobs );
//FOREACH( presyn, FOREACH( postsyn, ADD( neurprobs, EXP( EUCLID( presyn/x, presyn/y, postsyn/x, postsyn/y ) * A ) ) ) )

//This will effectively, iterate through with idx = presyn 1, 2, 3. Then while presyn = 1/2/3, I do postsyn = 1/2/3.  (Whoa?) can I always access its index too? Fuck.
//I would need to look through "Trace" to find which idx I am currently using for presyn. Fuck...
//At any rate, each one is pushing back a single value? They're each building their own vector? No, they don't return vectors, they are each PUSHING BACK a vector.
//The problem is that, I need to add corresp. And the corresp between presyn and postsyn and me is not clear...
//I'm just generating a flat list. Next, I want to back and for each presyn, sum the guys. Well, I need to know where I start/end in that array.
//With respect to postsyn, each of my points is also generated from a specific postsyn. So, for each point I add, push back corresponding pre/postsyn idx.
//For A as well? So, I literally go back through my trace for that. That seems reasonable.
//The add function does that specifically. When you add (to variable named X), it will go back up trade, and make a corresp between add and every model in the trace,
//and it will push back the corresponding idx. OK.

//It's fine to "push" it, but what about when I "find" it? Like, when I want to read variables in future?
//OK, so, now it finished constructing it, it needs to know to "reverse compute" the opposite side of the corresp (i.e. fill it up). For every corresp it created.
//Specifically it needs to push back start, size, and corresp.

//Note, I am literally generating BLAH. OOH HAVE IT RETURN A SYMVAR!!! No, symvar have everything in them. Corresps contain TARG model (not "source" model, which should
//be parent I assume ).

//REV: OK, once I finished generating that, next I generate what? I'm still generating temp variables. The end goal is to generate (co-generate) some number of other guys.
//Forall (size_to_gen), DRAW_FROM_PROB( myprobarray ) //This returns INDEX of winning point, +0.5 to make sure I can cast to a size_t safely...error of 0.5 is pretty much
//impossible?

//OK, so, remember, I am trying to co-generate (the size of) SYN, and simultaneously set presyn and postsyn, which will be the same size.
//So, just have the idxs selected?

//Code cumsum, and multinomial draw in here? Fuck... bi-search. Fuck.
//How about, yea, variables do return their whole index trees (values?). Furthermore, we can access each one's index INSIDE THE STRING. Which is again, returned as REAL_T

//Best case: return symmodel + idx.
//Have symmodel contain both valu and idxs (or something?). Which I can choose to access if I'm writing it.

//I can fix this by making each number a CONST, adding it to (that) model as a named variable, and then returning a reference to that (note idx==0)


//    This is the problem, some might have side effects? If it is a "set" type thing, what the fuck am I doing?
///   Do I always assume I'm inside the right model? Then I could "set" targets. But, the problem is that, I want DOCMD to have same signature.
//    Which is fine, but then why return REAL_T. Just return a fucking vector<real_t>. Problem is, I am trying to operate on an INDEX. POssibly through many indices.
//    For example, I might want to go into it, and inside that, do something. So, like, SUM( blah ). It sums "inside" each thing it gets too (e.g. if it gets vect).
//    How would I do like, um, SUM( hole/X ). If there are multiple holes, it will within each hole, get N guys. That is the problem.
//    E.g. SUM(  SUM( MULT(E,x) ) )
//    So, MULT(E*X), E and X return vectors. So I mult all the Es togethr? That's not right. That's why I need a foreach type thing.
//    Just leave it how it is, the problem right now is correspondences orz. And finding variables through holes. I'm returning REAL_T because it is the type
//    expected. Some other guys might expect or be able to handle DIFFERENT types, e.g. VECT. Howevr, in that case, they would call diff subroutines etc.
//    within just MULT(), what does it mult? if it gets back a bunch of vectors of the same size. How do I handle "within" those vectors? I can'te. I must know how to
//compress them to single value for MULT. However, for a given single vector, oh it knows what to do :)

//For example, I want to SUM over all holes, the product of E*X, for each idx. E and X each return (individually) a vector (theoretically...?) So, I would call MULT( E, X )
// that by default, does pairwise, and returns an item of the same dimension. However, if argument is single, e.g. SUM( MULT(E, X) * pre/V ), it would SUM a single vector.
//Then, that would all be summed together, as a single vector, over all holes. Problem is that pre/V returns a single item? For all guys. Fuck? Fuck it. Return a pointer.
//Much much much easier to return a tmp, but then I can't reference it later without doing nasty ADD only at the beginning of each DOCMD.


//OK TODO FINAL:
//1 ) struct VARPTR ( symvarptr, std::vect<size_t> idxs, real_t val )
//    functs return VARPTR. Usually they just use idxs[0] in var. If idxs.size() = 0, you can get the real_t.

//2 ) add GLOBAL_STORE of symmodels. Just an array of symmodels, no nesting!
//    all existing guys are updated to search through that to resolve variables (first)

//3 ) since functions return VARPTR, varptr contains a real_t for handling numeric constants (accessed if idx=0, only after a direct "READ"?)

//4 ) functions can ADD, in which case they co-generate correspondences (with what models? All in trace?). CF abvoe.

//Note, this will not work every time I update it. I will not be able to find the var either, since it is (FUCK FUCK FUCK), ntmp vars. How about, replace in that string,
//with tmpvar name? Ah... Or just make a global value for it. CONST var? At this point, I can't change the update function...I don't want to do some compilation shit.
//Fuck...how about, if vect size is zero, read the single value or some shit like that ;)

//Problem is e.g. if I literally return new values each time, I can never modify it!! But, who cares about return value, if I'm modifying it ;) But, what to modify,
//is the difficulty I guess? whatever, leave as is...

//FOREACH( presyn, FOREACH( size_to_gen, MULTINOM( presyn/neurprobs


//Ooh, how to do "add"? Well, we specifically will do either ADDFOREACH() at the innermost level, in which case it will add (for each call) to each guy.
//Problem is when we add to blah, we do it there. Ah, we can do it separately for each LINE. But based on index we chose, we lost track of which "pre" and "post"
//it was
//So we need to mark/add state at that point. Fine.
//So, "ADD" is added at that point in time. Could exist multiple times in each. Problem is we can't predict how much to add i.e. how many to alloc on GPU.
//They are basically local "push", which are coalesced and added at the end.
//Right, in which case we are returning individual vectors...
//For example, we make the vars in GEN.
//Meh, gen locally, then for each, add that. But then I won't know which was added...
//SO, in the end, I need to be able to ADD multiple in the same gen function.
//If ADD is returning a vector, it won't work unless I allow comma-separated. AH, like ADD( x/var1, pre, x/var2, post, MULTINOM( blah ) ). In this way, each other one
//will add it. Fine, so multinom returned a single value (a single index?)

//And, at the very end, these can all be coalesced into a single add. This is the issue is that it's not returning a single variable, but multiple lol...
//In the end, I'm returning arbitrarily dimensional data you fucktard hahaha.

//How does it know where to "split up" in GPU? lol...
//Always at "for each"? Fuck. Fuck fuck. So, when I do the "gen" thing, I need to know how that translates to being parallelizable. Normally, it is for each index that
//it is run on (only the original indices, i.e. the first level). That's the problem with GEN, is for each line, it needs to know how many to run on. So, like FOREACH,
//and it gets the size. But the size might not be determined yet haha...ok.

//it will determine num threads....not might not all fit in threads/blocks, so need to loop within (fuck)
//Some threads may handle multiple "pointers" of the data, fine. On the GPU.

//OK, still major problem is how to add multiple at same time. If I'm literally pushing back directly, it will fuck up when I do it on the GPU.
//So, I need to "return" i.e. bubble back at least to top level.
//Obvious stupid solution is to return not SYMVAR, but vector<symvar>. I.e. I can return multiple symvars. Problem is, how do I know the order? Well, it's order I put
//them in. I know their names I guess. At this point, it returns (still) a tmp vector. At at this top level (which has now returned to  top level thread), it will
//do the stuff. Shit, allocations are going to be nasty as fuck on the GPU. Within each sub-thread, I will be using some vector-like thing. And it will need to push back
//for every single one. I can of course predictively do it, based on initial FOREACH( ) type thing...
//Meh, details. At any rate, it will compile it into a thing, but problem is, it has no fucking idea it is nested. "parallels" can only happen at first level.
//I need to know it is first level, which is impossible in the function...unless I check trace. Anyway, So, ADDFORALL type thing. Yea, specify a specific guy.

//Fuck, for GPU, how will it implement it?
//For single guys (normal updates) it's obvious. For will be done individually in for loop, everything else is in parallel.

//For add functions, it's more complex. At the first level, I need an "update" statement, that says, I'm going to do this for all NEURONS. That is the key
//for updating on GPU. It will tell me how many to do. I can't just parse a single guy into a single GPU statement as I could in the other case.
//Wait, no, I can. It parses it into a single statement, but it needs to parse the first argument too for some cases. The first argument then will do a lookup
//to some variables size, and tell how many threads to spawn...I.e. those will be the "indices" it is iterating through.
//In that case, it will be the top level guy. problem is how I specify what/when to add! Ah, that is fine, it will return multiple up to that point, at that point,
//it will actually write them ;) I.e. I can nest "same calls"
//ADDFORALL( presyn,  pre, post, FORALL( postsyn, var, pre, var2, post, CMD ) )
//Second level ADDFORALL will return of course, 2 arrays directly? How do I know how many it will push? It never needs to coalesce it.
//At any rate, ADDROALL, it takes a string, but the thing is, the string, the variables, they represent return values from the CMD. In other words, I parse the cmd, the
//cmd does what? Does it make tmp vars? No..it just directly returns some number of guys. It just literally writes those in order!!! HAHAHAHA
//If ret val size doesn't match, tough luck, fuck the world (error at compilation time).
//Note, expected 'type' must match up? It will handle it seprately for each, based on the type of the read guy.
//Lol yea, just have it return a vector of [VARPTR]. Which inside, contain: ptr to symvar (not a model!), size_t of legal indices in it, and real_t of "const" value to return.
//So I can return N const values too if I want ;)


//OK so, REAL todo:

//1) functions now return vect<VARPTR>.
//   vect<VARPTR> is: ( vector<real_t>, vector<size_t> )
//   By default, functions only expect some number of ret vals depending on "my" requirements. I.e. it's totally based on MY parse!!! How many I expect.
//   For most/all current guys, it only expects one size in vect<VARPTR>. Furthermore, depending on my funct, I will just check that vector<size_t> is of size 0 (or 1?),
//   and read directly from the var? 

//2) GLOBAL_STORE of symmodels for temp variables.

//3) Function to PUSHFORALL( X, a, b, c, CMD), will iterate for all idx in X, and will add to a, b, c coalesced results from CMD, which will return exactly a, b, c vars.
//   A/B/C are ignorant of what they are, but they are accessed in either GLOBAL_STORE or SYMMODEL space.
//   CMD can be any normal thing that iterates through individual indices. However, it can't/mustn't fuck with holes?

//4) As I add items/create vectors, I must somehow create correspondence with existing guys? This is really bad... Assume all are either identity, or param (const) type.

//How do I explicitly get indices? Some guys literally just return the indices without vars? haha. If vars=0, and indices>0, use that.
//Do some functions return indices? Yea...for example, MULTINOM does. If we are calling multinom, and calling function is not expecting indices, we are fucked.
//but, I don't want to check at every function, when I get a result back, that I didn't get a MULTINOM type result. That is fucked...
//How can I check? Just always return a vector of reals, ignore the fact that I need to get size_t? Choose which one I use/how I interpret it? Just handle whatever I get
//so if I got back zero reals, it is like, wtf wtf error? Rofl. I could literally build a list of indices in the TOTAL OVERALL guy to do? Nah. I never build the correspondence
//I guess? No, I do. fuck..how does it correspond to me though? In other words, how do I know where I start/end? I have added a new var, and for each one it added, it knows
//start and size in that array of me. So I added corresp at the beginning ok, only during the PUSHFORALL()p?!?!?!?!

//FULL GUY:

// # REV: new vars in there. Note, since thy are "add" it is only 1 by default ;)
// # Accessing global store idx 0 from index 0

//idealx = (maxx-minx) / 2 + minx
//idealy = (maxx-minx) / 2 + minx
//idealz = (maxx-minx) / 2 + minx
//newlocal(myprobs)

// # REV: this set correspondence at the lowest level too. Myprobs is a local MODEL,
// # and thus now has corresp set to PRESYN (but not to postsyn? Fuck?) I guess to
// # postsyn too? Postsyn is literally its index. Yea, I like that. SIZE_T that is
// # returned is used for that. Presyn idx is used for presyn idx.
// # Furthermore, MYPROBS has correspondence to A also? No...no need...it is checked
// # as a PARAM, so it doesn't error out there.

// # Accessing model presyn from idx X, accessing postsyn from idx Y, accessing
// # presyn/xpos from idx X (because it can't find it in postsyn, so it bubbles back
// # up TRACE)
// # Accessing postsyn/xpos from from idx Y (because it finds it in presyn).
// # NOTE: idx X and idx Y are generated "online", I don't go through correspondence
// # because it is a FORALL, which means, access arg directly.
// # After all, there is no relationship between presyn and postsyn anyway! HAha. Good.
// # **** This will have created CORRESP for myprobs->presyn and myprobs->postsyn
// # (implicit for 2nd, generated from opposite at end of function?)

//PUSHFORALL( presyn, myprobs, FORALL( postsyn, ( DIST( presyn/x, postsyn/x ) * A ) ) )

// # Next step is to integrate each of these
// # Only one arg, so it sums within the returned value.
// # This accesses the sub-vector of myprobs corresponding to presyn idx X

//newlocal(integs)
//PUSHFORALL( presyn, integs, SUM( myprobs ) )

// # Now I make some local guys.
// # postsyn/x returned indiv? Fuck, just do in single thread for simplicity?
// # REV: this uses corresp between idealx, A (globals), and postsyn which is idx.

//idealinteg = SUMFORALL( postsyn, DIST( idealx, postsyn/x ) * A )

// # REV: how to get "size" or "index" of a variable programatically? Use |BLAH| haha.

//sumideal = presyn/SIZE * idealinteg

//volume = maxx-minx * maxy-miny * maxz-minz
//correctionratio = (targdensity*volume) / sumideal

// # REV, I could draw separately and store a variable that contains indices...
// # FINAL, resulting synapses
// # REV: I want to do it "integs time" haha...
// # REV: this uses correspondence from presyn->myprobs, and presyn->integs (straight)
// # REV: MULTINOM knows how to handle that. Problem is that, multinom returns a single
// # REV: value (idx?). I need to push back the presyn of that to PRESYN

// # REV: multinom returns a vector of selected guys. Fuck. That vector is not result
// # of anything...? It's like a new fucking idxs generated by local haha. Like FORALL.
// # REV: multinom always returns IDXs only. How does PUSHFORALL know that?

//newlocal( selectedidxs )
//PUSHFORALL( presyn, selectedidxs, MULTINOM( myprobs/IDX, integs ) )

// # REV: now selectedidxs, contains for all presyn, a list of N selected idxs (in
// # the POSTSYN list! But, does it know that?)
// # PUSHFORALL( presyn, presyn, postsyn, MULTINOM( myprobs, integs ) )

// # REV: wow big ugly hack, I *know* selectedidxs is RAW postsyn. But make sure
// # REV: by getting idx of corresponding postsyn
// # REV: this says, get my fucking idx in POSTSYN fuck.
// # REV: what do idx have to presyn?
// # REV: this returns raw....double. fine. I don't want to wrap it in READ though...
// # REV: i could do this separately now though ;)
// # PUSHFORALL( presyn, presyn, postsyn, READ(selectedidxs->presyn/IDX, selectedidxs->postsyn/IDX) )
//PUSHFORALL( presyn, presyn, selectedidxs->presyn/IDX )
//PUSHFORALL( presyn, postsyn, selectedidxs->postsyn/IDX )

// # In one line 
// # PUSHFORALL( presyn, presyn, postsyn, MULTINOM( myprobs, integs ) )
// # OK, easy, never push back more than one I guess. Easier that way...
// # REV: um, shit, fuck, ass shit. I could code a GET_CORRESP( toX, toY, ..., (idxlist) ). Which would get corresponding values in each toX, and toY etc. models.
// # and return them as result... but would it exist? I mean, I know because it is there, kind of ghetto. I like the other way where I treat idxs as first-class citizens.
// # REV: *always* make a temp var.


//REV: this works, assuming everything works properly. So, do it.

// QUESTIONS; How do I add corresp? How do I pass variables (like, global variables) to generator. Generator automatically has/searches for them? They are automatically (all?)
//  put in the global store. It expects some "named" variables from global varlist. Which may be of some size? Don't worry about that now, those are added at GEN creation
//(added but not filled). They are initialized/filled from varlist. Um, shit, in that case, they must be pre-stored in there, generated from like, data passed by default.
//OK,.
//I can automatically tell which guys I write with this based on analysis of "PUSHED TO" in main model :)
// ALso, which are read from, so I can build dependencies, without user explicitly specifying.


//newlocal integs;
//Haha make sum do it after all if it has only a single argument? Ghetto...
//What if I want to "pass through" using sumforall? Like, DOFORALL. Disallow it? Point of that is to go through holes. Fuck it for now ;)
//In this case, myprobs will return a vector, which it will sum.
//Referencing a variable will (always) return my whole list of values! Oh, it's a read! I like that... So, I could reimplement the other guy then...oh well.
//Problem in old situation, is that it was/could have been a hole that had "return" references to myself.
//Fine, but in general, when I resolve a model, I do so with a given index right. It returns an ELEM PTR. Ah, that is the problem? When I  do a "find" I pass
//idx with it, which returns index not in current model, but index of index of target?
//Ah, remeber I hacked SUMFORALL, so that now SUMFORALL uses previous and previous-previous TRACE to determine which index to read. I could streamline this by
//Leave it as it is, or I might introduce problems.
//So, main issue is that, I need a way to extract a vector of values, from a guy/corresp. For a given index, that is what I should return. Fuck.
//That is deafult thing. Like, I execute READ using an index, it sure as fuck better return a vector of guys. Note, "READ"






//Note, FORALL generates my OWN idx, I don't go through any guy. Fine. What about for
//being inside other guys, like MULT. It won't be.

//Make examples of everything I want to do.




//ADDF( x/var1, pre, x/var2, post, MULTINOM( blah ) )

//Because, at the end, I have local gens...



//MAKETMPVAR( neurprobs, 



//DOBLAH = EXP( EUCLIDDIST( presyn/x, presyn/y, presyn/z, postsyn/x, postsyn/y, postsyn/z ) * A )

//So, here is problem. In this case, I take a model
//I don't know that I was called from a GENERATOR though, that's the issue. In between each line though, I do.
//So, in between each line, I know something was created? Ah, instead of literal string called by DOCMD, I make a DOGENCMD()
//which is similar? Important thing is that I can um, check everything.
FUNCDECL(ADDFORALL)
{
}





struct generator
  :
  public std::enable_shared_from_this<generator>

{
  //Takes source model (variable?) I guess.
  void generate()
  {
    //genfunct has access to THIS (i.e. this generator). So it can access: model, and varstogen. Good.
    //RULES: I can only add new var at the base level.
    //They will have side effects...
    genfunct.execute();
  }

  //either has a pointer to a corresp, or a model?

  genfunct_t genfunct; //parent model is what? the model that it generates? heh.
  
  std::shared_ptr<symmodel> model;
  
  vector<string> varstogen;

  void add_to_genfunct( const string& s )
  {
    if( !genfunct.gen )
      {
	genfunct.gen = shared_from_this();
      }

    genfunct.add( s );
  }
  
  //List of variables that will be simultaneously generated.
  //I can find them in model...note some may be connections.
  generator( const vector<string>& genlist, const std::shared_ptr<symmodel>& m )
  : model( m ), varstogen( genlist )
  {
  }
  
};

